{"status": "Judging", "problem_id": 1208, "language": "cpp", "username": "diyanqi@qq.com", "code": "#include <cstdio>\r\n#include <cstring>\r\n#include <climits>\r\n\r\n#include <queue>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\n#define NMAX 400\r\n#define MMAX 15000\r\n#define INF 0x3f3f3f3f3f3f3f3f\r\n\r\ntypedef long long i64;\r\n\r\nstruct Edge {\r\n    Edge(int _u, int _v, i64 _w, i64 _c)\r\n        : u(_u), v(_v), w(_w), c(_c) {}\r\n\r\n    int u, v;\r\n    i64 w, c;\r\n    Edge *rev;\r\n};\r\n\r\nstatic int n, m;\r\nstatic vector<Edge *> G[NMAX + 10];\r\n\r\nvoid link(int u, int v, i64 w, i64 c) {\r\n    auto e1 = new Edge(u, v, w, c);\r\n    auto e2 = new Edge(v, u, -w, 0);\r\n    e1->rev = e2;\r\n    e2->rev = e1;\r\n\r\n    G[u].push_back(e1);\r\n    G[v].push_back(e2);\r\n}\r\n\r\nstatic i64  d[NMAX + 10], h[NMAX + 10];\r\nstatic Edge *ed[NMAX + 10];\r\nstatic bool in[NMAX + 10];\r\n\r\nvoid spfa(int s) {\r\n    for (int i = 1; i <= n; i++)\r\n        h[i] = INF;\r\n\r\n    h[s] = 0;\r\n\r\n    queue<int> q;\r\n    q.push(s);\r\n    in[s] = true;\r\n\r\n    do {\r\n        int u = q.front();\r\n        q.pop();\r\n\r\n        for (auto e : G[u])\r\n            if (e->c && h[e->v] > h[u] + e->w) {\r\n                h[e->v] = h[u] + e->w;\r\n                ed[e->v] = e;\r\n\r\n                if (!in[e->v]) {\r\n                    q.push(e->v);\r\n                    in[e->v] = true;\r\n                }\r\n            }\r\n    } while (!q.empty());\r\n}\r\n\r\nvoid dijkstra(int s) {\r\n    struct State {\r\n        int u;\r\n        i64 t;\r\n\r\n        bool operator<(const State &z) const {\r\n            return t > z.t;\r\n        }\r\n    };\r\n\r\n    memset(in + 1, 0, n);\r\n\r\n    for (int i = 1; i <= n; i++)\r\n        d[i] = INF;\r\n\r\n    d[s] = 0;\r\n\r\n    priority_queue<State> q;\r\n    q.push({s, 0});\r\n\r\n    do {\r\n        auto _ = q.top();\r\n        q.pop();\r\n        int u = _.u;\r\n\r\n        if (in[u])\r\n            continue;\r\n\r\n        in[u] = true;\r\n\r\n        for (auto e : G[u])\r\n            if (e->c && d[e->v] > d[u] + e->w + h[u] - h[e->v]) {\r\n                d[e->v] = d[u] + e->w + h[u] - h[e->v];\r\n                ed[e->v] = e;\r\n                q.push({e->v, d[e->v]});\r\n            }\r\n    } while (!q.empty());\r\n}\r\n\r\nint main() {\r\n    scanf(\"%d%d\", &n, &m);\r\n\r\n    while (m--) {\r\n        int u, v;\r\n        i64 w, c;\r\n        scanf(\"%d%d%lld%lld\", &u, &v, &c, &w);\r\n        link(u, v, w, c);\r\n    }\r\n\r\n    int s = 1, t = n;\r\n    spfa(s);\r\n    i64 flow = 0, cost = 0;\r\n\r\n    while (h[t] < INF) {\r\n        for (int i = 1; i <= n; i++)\r\n            h[i] += d[i];\r\n\r\n        i64 mi = INF;\r\n\r\n        for (int x = t; x != s; x = ed[x]->u)\r\n            mi = min(mi, ed[x]->c);\r\n\r\n        flow += mi;\r\n        cost += mi * h[n];\r\n\r\n        for (int x = t; x != s; x = ed[x]->u) {\r\n            ed[x]->c -= mi;\r\n            ed[x]->rev->c += mi;\r\n        }\r\n\r\n        dijkstra(s);\r\n    }\r\n\r\n    printf(\"%lld %lld\\n\", flow, cost);\r\n    return 0;\r\n}"}